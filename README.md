# Automated Hypermarket Scheduling Engine

## Motivation

After working for two years in Prisma (a grocery store), I encountered the art of making the cashier schedule for the cashiers in a big hypermarket. I immediately saw the potential to automate it to increase the efficiency of day-to-day operations, because this cashier schedule has to be made every day from scratch due to there being a different availability of cashiers day-by-day. The schedule essentially tells which checkout each cashier will be working at any moment during the day, and when each cashier will have their breaks. At first, it sounded easy, but while digging deeper, I realized that it is a complex problem after all.

My cashier schedule **program** solves all the issues; it assigns cashiers automatically to checkouts, keeps track of all the breaks, and ensures continuity and efficiency both in the aspect of keeping checkouts **continuously** open but also in the aspect of the cashiers having to change the checkout they are working at for as little as possible, all this while taking the different requirements into account like: cashiers' breaks, the ratio of tobacco checkouts open of all checkouts, **checkout** opening and closing times, and also whether a checkout is required to be open at all times.

## Principles of the algorithm and the scheduler

A reliever (or **tauottaja** in **Finnish**), is a cashier who is assigned to let cashiers in checkouts have breaks while keeping the checkout **continuously** open. What happens is that the reliever comes and replaces the cashier in the checkout to let the cashier have their scheduled break, and after the break is finished, the cashier comes back and lets the reliever continue relieving other cashiers.

Each cashier is either having their own breaks covered by themselves or a reliever. The optimal is obviously to have a reliever covering the break so the checkout operations can continue **seamlessly** and without any disturbance for the customers. Closing the checkout not only is inefficient but also causes additional costs due to the inefficiency. Still, sometimes it's necessary to have a cashier cover their own break due to too few cashiers available or if there's no other breaks needing to be covered in the near **future**. It doesn't make sense to have one cashier close their own checkout just to be able to relieve one single cashier.

There were essentially two choices for me **on** how to generate the breaks schedule and the checkouts schedule, either create the breaks schedule first and then create **the** checkouts schedule, or vice versa. Creating the checkouts list first would have been really complex due to the constraints (ratio of tobacco checkouts and checkouts required to be open). If I had created it first, it would have been really difficult to follow all the constraints because I need to ensure that all constraints are followed at all times. I decided to first assign breaks to all cashiers and with the basis of that, I could assign checkouts to cashiers and at the same time ensure that all constraints are followed.

## The algorithm and the architecture

I started this project two years ago, and finished it already once back some years ago, but the code was really bad. At some point I made it a bit more functional **in** style, but I was still not satisfied with the quality of the code; it was really messy, hard to read, and any changes would have broken it most likely. While I'm not so proud of the first versions, I am really proud of how my professional skills have developed and how this project demonstrates my development as a software engineer. This project has evolved to be a well-working application with a solid codebase that adheres **to** core OOP principles and displays my ability to model and solve a complex, real-world problem.

The project is separated into three main folders:

1. **`managers`** that contain the main "managers" of the project; the objects are `BreakManager`, `CheckoutManager`, and `DataManager`. Almost like they could be some real-world job titles assigned to employees, **although** these job titles would maybe have a **little bit** too little **responsibility** :D. But separating the managers into three smaller objects that have a very specific task and that contain all core logic was a good choice in my opinion.

2. **`collections`** that contain all the collections. **What do** I mean by collection in this context? Because I work a lot with time intervals, they are the core of the project, so I decided to create my own custom **data structure** for holding those time intervals. It contains `CashierScheduleCollection`, `CheckoutScheduleCollection`, `ScheduleCollectionBase`, and `TimeIntervalCollection`.

3. **`models`**, the folder that contain all the real-world entities or concepts. The `models` folder contains `AvailableInterval`, `BaseAssignment`, `BreakAssignment`, `Cashier`, `CheckoutAssignment`, `Checkout`, **and** `TimeInterval`.

Now I will explain what my thought process was behind my folders and whole architecture, and also the relations between the objects.

### Config and Cashiers shifts

There are two files that are intended to be modified by the person generating the list, if needed. One is the `config.json` file, and the other is the `cashiers.json`. `cashiers.json` is pretty straightforward; it is a list of json objects that each contain the cashier name, shift start time, and shift end time.

`config.json` contains:

1. `checkout_time_groups` where the user can assign **an** `opening_time` and a `closing_time`, `mandatory_open` (boolean) if the checkout(s) are required to stay open during their whole **shift**, and all the checkouts those rules apply for.

2. `checkouts_filling_order` that determines the filling order of the checkouts; it contains all checkouts that are NOT required to stay open. From the checkout to fill first to the one that is filled last (left to right).

3. `tobacco_checkouts` that contains the checkouts that can sell tobacco.

4. `tobacco_ratio_pool` that contains all checkouts that should be included when calculating the ratio of tobacco checkouts.

5. `tobacco_checkout_ratios` that is a list of json objects containing information about the ratios. Each object contain `max_total_checkouts` and `tobacco_checkouts`, and the objects are ordered from smallest `max_total_checkouts` to the biggest.

### The TimeInterval object

While developing the project further, the first core concept that I developed was the `TimeInterval`. Because this scheduling application relies really heavily on time intervals. In the first versions of the project, I did not even have a `TimeInterval` object; I was working with raw `datetime` objects, and I quickly realized that basically the whole project relies on time intervals and that there's a lot of duplication, and that it's so difficult to read and understand hundreds of lines with comparisons of `datetime` objects. So I created the `TimeInterval` object with multiple methods for comparing the `TimeInterval` objects with one another. But I was still not so satisfied. `TimeInterval` had a lot of unnecessary methods that were necessary for being able to compare them with **each other**. Those methods were used for example in assisting me to keep lists that contained `TimeInterval` objects sorted. To solve the problem of having `TimeIntervals` in a list, sorted and not overlapping, I created the `TimeIntervalCollection`.

### TimeIntervalCollection

The `TimeIntervalCollection` is essentially a custom **data structure** that uses **Python's** lists under the hood. It ensures that the `TimeIntervals` are always sorted and never overlap with one another. But only having a `TimeIntervalCollection` was not enough because each entity that has a schedule, like `Cashier` and `Checkout`, **needs** a `boundary_interval` for when they are available. I decided to use composition and create an abstract `ScheduleCollectionBase` class.

### ScheduleCollectionBase

The `ScheduleCollectionBase` is an abstract class that has a `TimeIntervalCollection` and also additional instance variables like `boundary_interval` and `_availability`. It essentially acts as the man-in-the-middle that receives orders from the owner entity (`Cashier` or `Checkout`) and delegates some tasks to the `TimeIntervalCollection` while also using the additional information the instance variables `boundary_interval` **and** `_availability` provide. While in theory I think I could have extended the `TimeIntervalCollection`, it felt more natural for me for entities to have a schedule and the schedule having a `TimeIntervalCollection` for storing the `TimeIntervals`. Also because of past experiences, I think that composition was better than inheritance in this case.

### BaseAssignment, BreakAssignment and CheckoutAssignment

I had an issue with modeling the events that represent some kind of `TimeInterval`, because I wanted all of the schedules to reference the same object if they were the same thing essentially. Let's say a break of a cashier; **it** sounds simple, but the break can have a reliever or not, so I had to figure out how I will model such a simple thing, that maybe wasn't so simple after all. I wanted the break to be the same object in the checkout, **the** cashier (whose break it is), and the reliever. I could have had multiple objects (`RelieverAssignment`, `CheckoutAssignment` (that already exists for normal assignments), and `CashierBreakAssignment`) representing the same break; my architecture or logic did not prevent it, but I thought that maybe it's the best to still not do it to prevent any bugs or corrupted data from happening, because those bugs could be pretty tricky to solve. Also I know that with one object representing a break, it could be beneficial in the future if I would want to change the logic and be able to move breaks after they have been assigned already to cashiers, checkouts, and relievers. This kind of thinking is obviously against YAGNI (You aren't **going to** need it), but taking overall good practices into account and the risk of data being corrupted, I decided to solve it by having only one **object**, and I don't think it's either semantically wrong.

Then I created `CheckoutAssignment`, that was pretty obvious and straightforward for me.

Because both of these objects are assignments that have a cashier who is the "main character" of the object and also **a** checkout, I thought it makes very much sense to have an abstract base class `BaseAssignment` that inherits from `TimeInterval` because these are some sort of `TimeIntervals`.

### Algorithm

As I already said earlier, first, I assign everyone their breaks and the times of the breaks. First, obviously while processing the `cashiers.json` data, I determine how many breaks each cashier gets based on the length of their shift, and then I calculate the ideal start and end times of the breaks by spreading all breaks evenly throughout their shift. After assigning all cashiers ideal break times, my `BreakManager` kicks in. **Its** job is now to create the breaks list or **tauotuslista** as it is in **Finnish**. So basically determining the best possible schedule for breaks by assigning relievers or having cashiers have breaks on their own.

I am using a greedy heuristic algorithm utilizing **a** weighted score to find the best **tauottajas**. To make the breaks flexible, I allowed them to move by maximum **of** 30 minutes (forward or backwards); this way they will fit **seamlessly** after one another. I sort all unassigned breaks chronologically and for each cashier I try to find the one who can cover the most, or more accurately, the one who gets the most points by my heuristic, and I continue looping until there are no breaks left to assign. So I start and try to always assign the break that has been moved $-30$ min backwards to the current selected cashier. If it doesn't fit, then I move to $-15$ min, etc., until $+30$ min. If it fits at some point in the selected **cashier's** schedule, I assign it there. By always testing $-30$, $-15$, $0$, $+15$, $+30$ min, I ensure that the breaks will fit well even if some cashiers' breaks are overlapping a **little bit**. Let's say Cashier X has a lunch break at 11:00-11:30, and Cashier Y a normal break at 11:15-11:30. You see they don't fit, but by moving Cashier **Y's** break $+15$ min, they fit **seamlessly**. I also had an issue of there being too few breaks assigned to a reliever, **because** it doesn't make too much sense to have a dedicated reliever to relieve just two single breaks that are not consecutive.

To solve the problem of there being too many breaks left out in times without many cashiers, I implemented the weighted score. The weighted score gives points: 1. if a break is consecutive with another break, 2. if a break ends before 11, and 3. if a break ends after 20. With the implementation of this heuristic and a minimum score requirement, I was able to prevent a reliever having only a very few coverages, but still to encourage the cashier to be a reliever if the breaks to relieve are consecutive and there's not many cashiers working. This is smart because when there **are** fewer cashiers and checkouts open **they** have a bigger impact compared to when **there are** many customers. It can also be more difficult to close a checkout to have a break because there might be a sudden rush of customers. Also the consecutive breaks bonus obviously favors the more efficient cashier of **the** cashiers who have a long shift and are able to handle very many **relieving duties**. So in that case also the most efficient cashier is chosen to be the reliever. If the minimum required score of the heuristic is not achieved for any cashier that includes a break **(x)**, then it is assigned no reliever and the cashier has to go to the break on their own.

The `CheckoutManager` is responsible for the crucial task of assigning available cashiers to open checkouts in real-time, minute by minute. Unlike the `BreakManager`, which uses a single Greedy Heuristic to find a global optimum for the whole break list, the `CheckoutManager` uses an event simulation logic based on **15-minute** time slices and a multi-tiered Priority Pipelining logic to make local, immediate assignment decisions. What the algorithm does is that it sees a time window of **15 minutes** and assigns cashiers; it does it from **the** start until the last checkout is closed. The advantages are clear, because it is difficult to assign a cashier to a specific checkout for a long interval without knowing which other checkouts will be open, due to the need of following all config constraints. So I decided that it's the easiest to think of it as a puzzle to glue together and advance **in 15-minute** intervals at a time.

By assigning cashiers to checkouts **in 15-minute** intervals at a time, I am able to determine easily which cashiers are working or available to work (e.g., either completely free cashiers or a cashier who is on their reliever duty). This way I know how many checkouts will be open, and I will also be able to determine whether there's enough cashiers to also attend the checkouts that are required to be open. After prioritizing the mandatory checkouts, I favor keeping the already open checkouts to stay open, to favor smooth and efficient transitions, efficiency, and **a** great customer experience by preventing unnecessarily opening or closing lanes. After those checkouts are chosen to be attended, if there's still checkouts to be selected to **be** attended, I fill lanes according to the predefined `checkout_filling_order` in **the** config. After **deciding** all checkouts that will be attended, I do tobacco ratio balancing. The algorithm applies a ratio optimization loop to ensure that within the designated tobacco-selling checkouts, the correct minimum number of lanes is open. If the current selection fails the ratio requirement, the algorithm will swap a lower-priority, non-tobacco checkout with an available tobacco checkout, guaranteeing compliance.

Once all checkouts to be filled are chosen, the algorithm assigns cashiers to those checkouts. The algorithm first attempts to extend the assignment of the cashier who was at that specific checkout in the previous time interval, preserving flow and continuity. If the previous cashier is now due for a break, the system automatically assigns their designated reliever to the checkout, guaranteeing the continuity of service. Only after prioritizing continuity and scheduled breaks does the system look to assign any remaining available cashiers to the remaining open checkouts, creating new `CheckoutAssignment` intervals.

This algorithm maximizes **efficiency** in **the** breaks schedule and also maximizes operational efficiency and customer-friendly checkout assignments.